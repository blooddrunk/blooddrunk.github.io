<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Cancelable Promise]]></title>
      <url>%2F2017%2F02%2F06%2FCancelable-Promise%2F</url>
      <content type="text"><![CDATA[使用React时难免会需要在异步操作返回时调用setState()，如果此时该Component已经Unmount, React会抛出类似下面的错误： “Warning: setState(…): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op. Please check the code for the ContactPage component.” 解决这个问题最简单的方法就是在Lifecyle事件中手动设置并在调用setState()前检查某个标记位： inside a component123456789101112componentDidMount() &#123; this._isMounted = true&#125;componentWillUnmount() &#123; this._isMounted = false&#125;// 调用setState时if(this._isMounted) &#123; this.setState(...)&#125; 介于现在普遍都在使用Fetch API和Promise，更好的办法是使用可被Cancel的Promise，一个简单的实现如下： cancelable promise12345678910111213141516171819const makeCancelable = (promise) =&gt; &#123; let hasCanceled_ = false const wrappedPromise = new Promise((resolve, reject) =&gt; &#123; promise.then((val) =&gt; hasCanceled_ ? reject(&#123;isCanceled: true&#125;) : resolve(val) ) promise.catch((error) =&gt; hasCanceled_ ? reject(&#123;isCanceled: true&#125;) : reject(error) ) &#125;); return &#123; promise: wrappedPromise, cancel() &#123; hasCanceled_ = true; &#125;, &#125;&#125; 通过在原来返回Promise的调用外包裹一层Higher Order Function(虽然实际上返回的是一个新的对象), 然后在必要时(componentWillUnmount)取消掉: 12345678910const cancelablePromise = makeCancelable( new Promise(r =&gt; component.setState(&#123;...&#125;&#125;)));cancelablePromise .promise .then(() =&gt; console.log('resolved')) .catch((reason) =&gt; console.log('isCanceled', reason.isCanceled));cancelablePromise.cancel(); // Cancel the promise Eric Elliott大神给出了更完善的实现: https://github.com/ericelliott/speculation]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift 1.2中类的可失败构造方法]]></title>
      <url>%2F2015%2F05%2F10%2FSwift-Failable-Initializer%2F</url>
      <content type="text"><![CDATA[在Swift的构造函数中可以通过return nil来表示构造过程可能失败，如下： 123456789struct EvenNumberStruct &#123; let number: UInt init?(number: UInt) &#123; if number % 2 != 0 &#123; return nil &#125; self.number = number &#125; &#125; 然而如把上面的结构换成类，就会得到下面的错误: 1All stored properties of a class instance must be initialized before returning nil from an initializer 这是因为类的可失败构造函数只有在所有的类属性被初始化完成后才会触发失败行为，也就是说，在return nil之前，须保证所有的存储属性已被初始化（虽然我们的本意就是在这种情况下不必进行初始化）。在Swift 1.1中，可以将上边的存储属性改为可选类型，这样它就有一个默认的初始值nil。然而Swift 1.2中，改为UInt!并不会解决问题，事实上，只要把self.number = number放在return nil前面即可。 123456789101112131415class EvenNumber &#123; let number: UInt init?(number: UInt) &#123; self.number = number // 在我测试的XCode 6.3.1中，这段代码必须在return nil之前 if number % 2 != 0 &#123; return nil &#125; &#125; private init(num: UInt) &#123; self.number = num &#125; class func defaultNumber() -&gt; EvenNumber &#123; return EvenNumber(num: 2) &#125;&#125; 需要注意的是，对于常量属性，也就是用let声明的属性，必须确保这个属性在return nil之前，在所有可能的执行路径中都被初始化。如下代码会报variable ‘self.number’ used before initialized这样不知所云的错误 lang: swift123456789101112131415161718class EvenNumber &#123; let number: UInt! init?(number: UInt) &#123; if number &gt; 1 &#123; self.number = number &#125; if number % 2 != 0 &#123; return nil &#125; &#125; private init(num: UInt) &#123; self.number = num &#125; class func defaultNumber() -&gt; EvenNumber &#123; return EvenNumber(num: 2) &#125;&#125; 这可能跟Swift 1.2中的另一点改动有关：在一个构造函数中，常量属性只能被赋值一次，这意味着我们不再能在常量属性声明时赋予它一个初始值，然后在构造函数中覆盖它。（但同样由于Swift 1.2 的最新改动，我们可以先声明一个常量变量，只需保证在第一次使用它之前唯一的赋予它一个初始值即可。）把let改为var可解决上述问题，或者确保number在return nil前完全被初始化： 12345678910111213141516171819class EvenNumber &#123; let number: UInt! init?(number: UInt) &#123; if number &gt; 0 &#123; self.number = number &#125; else &#123; self.number = 0 &#125; if number % 2 != 0 &#123; return nil &#125; &#125; private init(num: UInt) &#123; self.number = num &#125; class func defaultNumber() -&gt; EvenNumber &#123; return EvenNumber(num: 2)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS应用程序生命周期]]></title>
      <url>%2F2015%2F04%2F27%2FIOS-Application-Lifecycle%2F</url>
      <content type="text"><![CDATA[iOS app主要有五个状态，Not running, Inactive, Active, Background, Suspended。它们之间的转换关系如下： 状态 说明 Not running app尚未被启动或者被用户或系统终止 Inactive app正在前台运行但是尚未开始接受UI事件（但它可能在执行其他代码）。一个app通常只在这个状态停留一段短暂的时间，然后转换到下个状态。在进入inactive状态时，由于马上就会过渡到background或active状态，app此时应该让自己保持不活动的状态。 Active app正在前台运行并在接受事件。这就是我们通常看到的前台程序的状态。一个处于active状态的app没有特殊的限制，它应当对用户操作做出响应。 Background app正在执行代码但没有显示在屏幕上。当用户退出一个app时，系统在中止这个app之前（进入suspended状态）使它短暂的置于background状态。在其他情况下，系统可能在后台启动某个app（或者唤醒一个处于suspended状态的app），给它一定时间来处理某些特定的任务。比如，系统可能唤醒一个app让它来进行后台下载，处理和位置的有关的事件，远程通知或其他类型的事件。处于background状态的app应当做的工作越少越好，它应该尽快把控制还给系统。 Suspended app还在内存中但没有在执行任何代码。系统会中止那些没有任何挂起的任务要完成的后台程序。系统可能在任何时候清理这些程序来为其他app提供空间。 启动某个app：not running -&gt; inactive -&gt; active 从一个app切换到另一个app：active -&gt; inactive -&gt; background -&gt; suspended AppDelegate.swiftXcode自动提供的AppDelegate类（实现了UIApplicationDelegate接口）包含这个app的启动代码和app生命周期的重要状态变化。简单介绍一下状态发生变化会被调用的重要方法： Not running -&gt; Inactive12optional func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject : AnyObject]?) -&gt; Bool launchOptions参数是一个包括了app被启动原因的字典（直接被用户启动的情况下可能为空） 也可以监视UIApplicationDidFinishLaunchingNotification系统通知实现相同的功能。 Active -&gt; Inactive1optional func applicationWillResignActive(_ application: UIApplication) 可以在这里暂停UI活动 Inactive -&gt; Active1optional func applicationDidBecomeActive(_ application: UIApplication) 也可以监视UIApplicationWillResignActiveNotification通知 Inactive -&gt; Background1optional func applicationDidEnterBackground(_ application: UIApplication) 在这个方法中释放共享资源，保存当前的应用程序状态（因为稍后它有可能被系统终止） 这个方法只有大概5秒的时间来执行相关任务。如果需要额外的时间来执行一些重要的清理的工作，调用beginBackgroundTaskWithExpirationHandler（比如将一些重要的信息传送到远程主机上），但它不应当用来简单的延长程序在后台的执行。通常在applicationDidEnterBackground中执行的任务越少越好。 也可以监视UIApplicationDidEnterBackgroundNotification通知 Background -&gt; Inactive1optional func applicationWillEnterForeground(_ application: UIApplication) app从后台重新回到前台，可以在这里撤销在app进入Background时做的一些工作。 也可以监视UIApplicationWillEnterForegroundNotification通知]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift中的NSNotification]]></title>
      <url>%2F2015%2F04%2F20%2FSwift-NSNotification%2F</url>
      <content type="text"><![CDATA[NSNotification提供了在应用程序中广播和接受消息的方法。 注册一个通知注册一个通知非常简单，获取默认的“通知中心”，然后调用addObserverForName方法 比如，监视用户在设置中改变字体的通知： 123456789101112let center = NSNotificationCenter.defaultCenter() // 获取用于系统通知的通知中心center.addObserverForName(UIContentSizeCategoryDidChangeNotification // 要监视的通知的名称 object: UIApplication.sharedApplication(), // 要见识的通知发送者(nil表示所有发送者) queue: NSOperationQueue.mainQueue()) // 用于执行接收到通知后要执行的闭包的队列&#123; notification in // 这其实是个trailing闭包，是第四个参数 // ... let c = notification.userInfo?[UIContentSizeCategoryNewValueKey] // 获取设置的新的字体，比如UIContentSizeCategorySmall // userInfo是随通知发送的包含相关信息的字典&#125; 创建一个通知除了监听系统通知，我们自己也可以创建通知 1234567let center = NSNotificationCenter.defaultCenter() // 获取用于系统通知的通知中心let notification = NSNotification(name: GPXURL.Notification, object: self, userInfo: [GPXURL.Key:url]) // 创建一个通知center.postNotification(notification) // 发送通知 然后我们就可以根据创建NSNotification是提供的参数(name和object)来监视这个通知了，并可以取得创建时提供的userInfo字典]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift的初始化限制导致的头痛问题]]></title>
      <url>%2F2015%2F04%2F15%2FSwift-Initialization-Trap%2F</url>
      <content type="text"><![CDATA[Swift在它的两步式构造过程中有严格的安全检查来保证构造的顺利进行，但这些初看上去有点晕的限制让我在初始化类自身的属性时费了不少劲。不是Property &#39;self.xx&#39; not initialized at super.init call，就是use of property &#39;xx&#39; in base object before super.init initializes it 先来复习一下Swift两步式构造过程的规则: 阶段1 某个指定构造器或便利构造器被调用； 完成新实例内存的分配，但此时内存还没有被初始化； 指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化； 指定构造器将调用父类的构造器，完成父类属性的初始化； 这个调用父类构造器的过程沿着构造器链一直往上执行，直到到达构造器链的最顶部； 当到达了构造器链最顶部，且已确保所有实例包含的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段1完成。 阶段2 从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问self、修改它的属性并调用实例方法等等。 最终，任意构造器链中的便利构造器可以有机会定制实例和使用self。 也就是说，在调用父类构造器前，必须先完成自身属性的初始化： 1234567891011class ViewController: UIViewController &#123; private let animator: UIDynamicAnimator required init(coder aDecoder: NSCoder) &#123; // ERROR: Property 'self.animator' not initialized at super.init call super.init(coder: aDecoder) animator = UIDynamicAnimator(referenceView: self.view) &#125;&#125; 然而，在父类的初始化过程完成前，也无法在子类中使用self.view，交换上面两行代码顺序后还是报错： 1234567891011class ViewController: UIViewController &#123; private let animator: UIDynamicAnimator required init(coder aDecoder: NSCoder) &#123; // use of property 'view' in base object before super.init initializes it animator = UIDynamicAnimator(referenceView: self.view) super.init(coder: aDecoder) &#125;&#125; 在一些情况下，我们可以把初始化分为两步来解决问题，不过在这里UIDynamicAnimator.referenceView是个只读属性，并不能奏效： 123456789101112class ViewController: UIViewController &#123; private let animator: UIDynamicAnimator required init(coder aDecoder: NSCoder) &#123; animator = UIDynamicAnimator() // 先不引用self super.init(coder: aDecoder) // ERROR: Cannot assign to the result of this expression animator.referenceView = self.view // 等父类构造过程完成 &#125;&#125; 更好一点的方式，将这个属性改为Optional，并确保它在较早的阶段(构造完成后)被赋值(比如viewDidLoad)： 1234567891011121314class ViewController: UIViewController &#123; private var animator: UIDynamicAnimator! // 使用隐式解包可选属性可以避免以后每次使用时显示解包的麻烦 required init(coder aDecoder: NSCoder) &#123; super.init(coder: aDecoder) &#125; override func viewDidLoad() &#123; super.viewDidLoad() animator = UIDynamicAnimator(referenceView: self.view) &#125;&#125; 此外，还可以使用延迟存储属性和立即执行的闭包(不使用闭包依然无法在此时使用self)： 1234567891011121314151617class ViewController: UIViewController &#123; // 延迟属性必须用var声明 lazy private var animator: UIDynamicAnimator = &#123; return UIDynamicAnimator(referenceView: self.view) &#125;() required init(coder aDecoder: NSCoder) &#123; super.init(coder: aDecoder) &#125; override func viewDidLoad() &#123; super.viewDidLoad() animator.addBehavior(UIGravityBehavior()) &#125;&#125; 这种方法的缺点是使用延迟属性的话就无法使用属性观察器了 我现在碰到的问题是，想在一个UIView的属性的didSet中调用setNeedsDisplay()，同时它的初始值构造时要用到self.bounds，因此无法使用延迟属性。使用可选值的话，又不知道如何在UIView中合理的给它一个初始值。烦。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift中的"toString"方法]]></title>
      <url>%2F2015%2F03%2F31%2FToString-in-Swift%2F</url>
      <content type="text"><![CDATA[在Swift为对象实现类似toString的方法非常简单：在相应的类、结构或枚举声明中实现Printable协议，然后实现该协议指定的description只读计算属性即可： 12345678910111213struct Rect: Printable &#123; var width: Double var height: Double var description: String &#123; return "width=\(width), height=\(height)" &#125;&#125;let r = Rect(width: 11, height: 22)println("My Rect: \(r)") 在playground中不知道为什么在右侧看到的结果跟没有实现Printable协议一样，这应该是playground的问题]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用Swift语言开发iOS8 App： Multiple MVC]]></title>
      <url>%2F2015%2F03%2F30%2FDeveloping-iOS-8-Apps-with-Swift-Multiple-MVCs%2F</url>
      <content type="text"><![CDATA[iOS有一些内置Controller，它们的视图是另一个MVC：UITabBarController, UISplitViewController, UINavigationController, UIPopoverController UITabBarController UITabBarController绘制在屏幕下方绘制了最多5个tab标签(如果超过5个会自动呈现一个管理超出部分的界面)，上方呈现当前选定的tab的MVC。事实上，下方的tab栏的icon, title都是由UITabBarController包含的MVC的Controller的 123var tabBarItem: UITabBarItem! 属性所决定。tar bar item通常在storyboard中拖放进来。 UISplitViewController UISplitViewController只包括两个MVC：通常左侧Master决定了右侧的Detail的内容(每次都会生成一个新的Detail)。只有在iPad和iPhone6+的横屏模式可以同时显示Master和Detail，在iPad竖屏时只显示Detail，滑动屏幕才能看到Master。在其他尺寸的设备中需要嵌入UINavigationController来让UISplitViewController正常工作，这是由Size Classes决定的 UINavigationController UINavigationController大量运用于“设置”菜单中。可以把它想象成一个后进先出的Stack，最初的元素叫做rootViewController，最上面的元素叫做visibleViewController，它们都是UINavigationController的属性，每当在当前设置页面中点击一个子项，就相当于在上面push一个新项，而每点一次“后退”，就会把最上边的项pop掉(完全丢弃)。UINavigationController只负责呈现了上方的标题栏，下方的内容由Stack最上方的MVC所决定。甚至标题的内容，和标题栏的按钮也是由当前显示的MVC决定的(navigationItem属性)。 获得子MVCUITabBarController, UISplitViewController, UINavigationController都一个数组属性表示它们包含的子MVC 123var viewControllers: [UIViewController] &#123; get set &#125; 相反的，每一个UIViewController也有三个对应的属性表示它是否在UITabBarController, UISplitViewController, UINavigationController中 12345678910var tabBarController: UITabBarController? &#123; get &#125;var splitViewController: UISplitViewController? &#123; get &#125;var navigationController: UINavigationController? &#123; get &#125;//在Master中获得Detailif let detailVC = splitViewController?.viewControllers[1] &#123; ...&#125; Segue创建好了子MVC后，我们还需要调用它们，这就是Segue，主要有以下几种Segue： Show Segue(如果在UINavigationController中，被调用的MVC就会被添加进UINavigationController的顶端，否则会展示为Modal窗口) Show Detail Segue(如果在UISplitViewController中，会展示一个Detail MVC，否则类似Show Segue) Modal Segue(展示为模态窗口，不太会用到) Popover Segue(展示为一个popover窗口，点击窗口以外的区域就会关闭该窗口) Segue每次都会创建一个新的MVC，旧的会被抛弃 在storyboard中建立好Segue关系(通常是通过Control/右键拖动，比如在调用MVC中的一个按钮到目标MVC，点击这个按钮就会展示目标MVC)并填写好Segue的id后，往往还需要为目标MVC提供一定的初始化数据，为此在调用MVC中overrideprepareForSegue方法： 1234567891011121314func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) &#123; if let identifier = segue.identifier &#123; switch identifier &#123; case “Show Graph”: if let vc = segue.destinationViewController as? CalcGraphController &#123; vc.property1 = ... vc.callMethodToSetItUp(...) &#125; default: break &#125; &#125;&#125; 第一个参数segue有两个重要的属性，第一个是identifier(在storyboard的Attribules inspector中设置），用来标识调用了哪个Segue，另一个destinationViewController表示目标MVC，可利用它暴露的借口来做一些初始化工作，注意它是AnyObject，需要转换类型 需要注意的是，prepareForSegue执行的时候，destinationViewController中的outlets并没有被初始化，需要避免假设outlets有值而引发异常]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用Swift语言开发iOS8 App： 生命周期]]></title>
      <url>%2F2015%2F03%2F30%2FDeveloping-iOS-8-Apps-with-Swift-Lifecycle%2F</url>
      <content type="text"><![CDATA[一个View Controller的生命周期中会调用一系列方法，我们常常需要override这些方法来实现某些功能。 初始化(通常是从storyboard开始) awakeFormNib(每一个来自storyboard的对象都会调用这个方法，包括Controller） prepareForSegue(为segue做一些准备工作) outlet获得值(这意味着在prepareForSegue时，destinationViewController的outlet还没有值) viewDidLoad(最常用的放置初始化代码的地方) viewWillAppear viewDidAppear(view出现时调用，可能会调用多次) viewWillDisappear viewDidDisappear(view消失时调用，可能会调用多次) viewWillLayoutSubviews viewDidLayoutSubviews(当一个view的frame改变，需要重新布局时调用，比如呈现、旋转，autolayout发生在”will”和”did”之间) didReceiveMemoryWarning(内存不足，非常罕见的情况)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用Swift语言开发iOS8 App： View]]></title>
      <url>%2F2015%2F03%2F28%2FDeveloping-iOS-8-Apps-with-Swift-Views%2F</url>
      <content type="text"><![CDATA[Paul Hegary的Swift课程中关于View的一些笔记 1. view(UIView的子类)代表了一块方形区域，定义的一块坐标空间用于绘制和处理事件 2. 一个view只有一个父view 123var superview: UIView? 但可能有多个子view 123var subviews: [AnyObject] // 应转换为UIView类型 subviews属性数组中位置靠后的view位于位置靠前的view的上面 3. 以编程方式创建并添加view 12345superV.addSubView(aView: UIView)subV.removeFromSuperView() 4. 在UIViewController中有一个属性，它表示了当前视图中最顶层的view，我们通常就是向这个顶级view中添加子view 123var view: UIView 5. 坐标系统，CGFloat CGFloat CGSize CGRect 123456789let cfg = CGFloat(aDouble) // 坐标系统的单位总是CGFloatvar point = CGFloat(x: 37.0, y: 55.2)var size = CGSize(width: 100.0, height: 50.0)let rect = CGRect(origin: aCGPoint, size: aCGSize) 坐标的原点位于左上角 坐标的单位是point，view的contentScaleFactor属性表示一个point有几个像素(通常是2) view的bounds(CGRect)属性表示了它在自己的坐标系统的边界，因此bounds的origin默认为0, 0 view的center(CGPoint)属性表示了它的中心在父view中的坐标(使用convertToPoint获得center在当前view的坐标) 类似的，frame(CGRect)属性表示它在父view坐标系统中的矩形边界 6. 自定义view：新建一个UIView的子类并 overridedrawRect方法。 不要直接调用drawRect，使用setNeedsDisplay来间接调用它以实现重绘 实现drawRect： 12345678910111213let path = UIBezierPath()path.moveToPoint(CGPoint(80, 50)) // assume screen is 160x250path.addLineToPoint(CGPoint(140, 150))path.addLineToPoint(CGPoint(10, 150))path.closePath()UIColor.greenColor().setFill() // note this is a method in UIColor, not UIBezierPathUIColor.redColor().setStroke() // note this is a method in UIColor, not UIBezierPathpath.linewidth = 3.0 // note this is a property in UIBezierPath, not UIColor 7. 字体。通常使用以下类静态方法获取不同类型文本的字体，而不是指定固定的大小： 123456789101112class func preferredFontForTextStyle(UIFontTextStyle) -&gt; UIFont// 部分可用的styleUIFontTextStyle.HeadlineUIFontTextStyle.BodyUIFontTextStyle.Footnote// 指定大小的系统字体，不要在用户内容中使用它们class func systemFontOfSize(pointSize: CGFloat) -&gt; UIFontclass func boldSystemFontOfSize(pointSize: CGFloat) -&gt; UIFont 8. bounds改变时view的行为 123var contentMode: UIViewContentMode 不缩放view，只移动到某个位置.Left/.Right/.Top/.Bottom/.TopRight/.TopLeft/.BottomRight/.BottomLeft/.Center 缩放.ScaleToFill/.ScaleAspectFill/.ScaleAspectFit，.ScaleToFill是默认选项 再次调用drawRect，重绘.Redraw]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift的一些标准内置函数]]></title>
      <url>%2F2015%2F03%2F27%2FSwift-Standard-Functions%2F</url>
      <content type="text"><![CDATA[Swift有一些全局标准函数在The Swift Programming Language并没有提到。在Paul Hegary的Swift课程中看到一些，做下笔记。 1234567891011121314// Collections包括Array, Dictionary, String// Sliceables包括Array, Stringlet sub = dropFirst(aSliceable) // 返回一个去掉第一个元素的新序列let sub = dropLast(aSliceable) // 返回一个去掉最后一个元素的新序列let first = first(aCollection) // 返回序列的第一个元素(可选值)let last = last(aCollection) // 返回序列的最后一个元素(可选值)let prefix = prefix(aSliceable, X: Int) // 返回序列的前X个元素的子序列let suffix = suffix(aSliceable, X: Int) // 返回序列的后X个元素的子序列let reversed = reverse(aCollection) // 返回倒序的序列，注意返回值是一个数组let backwardsString = String(reverse(str)) // 返回字符串的倒序let isEqual = equal(aSliceable1, aSliceable2) // 检查两个序列是否相等 此外正如由于Unicode码元的原因应该用countElements来获取字符串的长度，在Swift中也无法简单的用Int来表示String的Index，取而代之的是String.Index，而使用Range&lt;String.Index&gt;来表示字符串片段 1234567var str = "hello"let start = str.startIndex // 获得字符串的第一个字符的位置let end = str.endIndex // 获得字符串的最后一个字符的位置let index = advance(str.startIndex, 2) // 获得字符串第三个字符的位置(第一个字符之后两个)let substring = str[index..&lt;end] // 获得子串 上面的提到了Range，它表示Swift中序列的一个片段，在for-in循环中已经隐式使用过它了： 123456var r: Range&lt;Int&gt; = 1...7 // 或者用1..&lt;8表示一个半闭区间for i in r &#123; println(i)&#125; 借助Range&lt;String.Index&gt;我们可以实现类似IndexOf的效果(不知道有没有简单的方法)： 123456var str = "Hello, playground"let commaIndex = str.rangeOfString(",")!.startIndex // 5let stringBeforeComma = str.substringToIndex(commaIndex) // "Hello"str.removeRange(commaIndex..&lt;str.endIndex) // str = "Hello"，参数相当于Range&lt;String.Index&gt;(start: commaIndex, end: str.endIndex)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用Pandoc将中文编码Markdown转换为PDF]]></title>
      <url>%2F2015%2F03%2F25%2FConvert-Mardown-In-Chinese-To-Pdf-Using-Pandoc%2F</url>
      <content type="text"><![CDATA[Pandoc是一款著名的文档格式的转换器。借助Pandoc可以使用markdown或textile等简单的标记语言写作，再转换成各种主流的文本格式。不过想把中文编码的markdown转换成的格式良好的PDF还需要一些额外的帮助。 安装(Windows为例)下载对应的操作系统版本并安装。确定安装成功： 1pandoc --version 为了输出PDF还需要安装LaTex。Pandoc推荐MiKTex。转换时会自动获取需要的LaTex依赖包。 Mac OS请在下载页面获得帮助，我没有试过。Macbook空间太宝贵了。。 转换现在已经可以像下面这样进行转换了(注意，Pandoc输入和输出都使用UTF-8编码): 1pandoc test.markdown -o test.pdf 不过对于中文并没有这么简单。默认的LaText引擎pdflatex并不支持中文，我们需要在命令行中指定引擎为xelatex：--latex-engine=xelatex。此外还需要各种字体等配置才能正常的看到PDF。好在tzengyuxio提供了Latex转换模板。我们也可以编辑此模板，改变字体和各种边距行距等。最终的命令如下： 1pandoc resume.markdown -o resume.pdf --latex-engine=xelatex --template=pm-template.latex 这是这篇博文的PDF效果：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sublime Text快捷键 for Mac]]></title>
      <url>%2F2015%2F03%2F24%2FSublime-Text-Shortcuts-Mac%2F</url>
      <content type="text"><![CDATA[Sublime Text快捷键一览表(Mac) Edit Keypress Command ⌘ + X Cut line ⌘ + ↩ Insert line after ⌘ + ⇧ + ↩ Insert line before ⌘ + ⌃ + ↑ Move line/selection up ⌘ + ⌃ + ↓ Move line/selection down ⌘ + D Select word - Repeat to select next occurrence ⌘ + L Select line - Repeat to select next lines ⌃ + ⌘ + G Select all occurrences of current selection ⌃ + ⇧ + ↑ Extra cursor on the line above ⌃ + ⇧ + ↓ Extra cursor on the line below ⌃ + M Jump to closing parentheses Repeat to jump to opening parentheses ⌃ + ⇧ + M Select all contents of the current parentheses ⌃ + A Move to beginning of line ⌃ + E Move to end of line ⌘ + K, ⌘ + K Delete from cursor to end of line ⌘ + K + ⌫ Delete from cursor to start of line ⌘ + ] Indent current line(s) ⌘ + [ Un-indent current line(s) ⌘ + ⇧ + D Duplicate line(s) ⌘ + J Join line below to the end of the current line ⌘ + / Comment/un-comment current line ⌘ + ⌥ + / Block comment current selection ⌘ + Y Redo, or repeat last keyboard shortcut command ⌘ + ⇧ + V Paste and indent correctly ⌃ + Space Select next auto-complete suggestion ⌃ + U Soft undo; jumps to your last change before undoing change when repeated ⌃ + ⇧ + Up Column selection up ⌃ + ⇧ + Down Column selection down ⌃ + ⇧ + W Wrap Selection in html tag Navigation/Goto Anywhere Keypress Command ⌘ + P or ⌘ + T Quick-open files by name ⌘ + R Goto symbol Goto word in current file ⌃ + G Goto line in current file General Keypress Command ⌘ + ⇧ + P Command Palette ⌃ + ⌘ + F Python Console ⌃ + ⇧ + ⌘ + F Toggle fullscreen mode ⌃ + ` Toggle distraction-free mode ⌘ + K, ⌘ + B Toggle side bar ⌃ + ⇧ + P Show scope in status bar Find/Replace Keypress Command ⌘ + F Find ⌘ + ⌥ + F Replace ⌘ + ⇧ + F Find in files Scrolling Keypress Command ⌃ + V Scroll down one page ⌃ + L Center current line vertically in page ⌘ + Down Scroll to end of file ⌘ + Up Scroll to start of file Tabs Keypress Command ⌘ + ⇧ + t Open last closed tab ⌘ + [NUM] Jump to tab in current group where num is 1-9 ⌘ + 0 Jump to 10th tab in current group ⌘ + ⇧ + [ Cycle left through tabs ⌘ + ⇧ + ] Cycle right through tabs ^ + Tab Cycle up through recent tabs ⇧ + ^ + Tab Cycle down through recent tabs Find in files Split window Keypress Command ⌘ + ⌥ + 2 Split view into two columns ⌘ + ⌥ + 1 Revert view to single column ⌘ + ⌥ + 5 Set view to grid (4 groups) ⌃ + [NUM] Jump to group where num is 1-4 ⌃ + ⇧ + [NUM] Move file to specified group where num is 1-4 Bookmarks Keypress Command ⌘ + F2 Toggle bookmark F2 Next bookmark ⇧ + F2 Previous bookmark ⇧ + ⌘ + F2 Clear bookmark Text manipulation Keypress Command ⌘ + K, ⌘ + U Transform to Uppercase ⌘ + K, ⌘ + L Transform to Lowercase ⌘ + ⌃ + up, ⌘ + ⌃ + down Clip text upwards / downwards]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[让Redcarpet在Jekyll Github Pages中处理表格]]></title>
      <url>%2F2015%2F03%2F24%2FRender-Table-Using-Redcarpet%2F</url>
      <content type="text"><![CDATA[在_config.yml指定markdown解析器为Redcarpet后，还需配置其extensions来正确处理表格，值的格式为字符串数组 1234# in _config.ymlmarkdown: redcarpetredcarpet: extensions: ["tables"] 这样就可以用以下格式来书写表格，:冒号的位置代表了对齐的方向： 12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 输出： Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 其他可选的extensions参考Redcarpet的README 1234# in _config.ymlmarkdown: redcarpetredcarpet: extensions: ["no_intra_emphasis", "fenced_code_blocks", "autolink", "tables", "with_toc_data"]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于Jekyll]]></title>
      <url>%2F2015%2F03%2F24%2FAbout-Jekyll%2F</url>
      <content type="text"><![CDATA[Jekyll并不是一个博客软件，它只是一个静态网页生成引擎。它不包括页面模板和设计元素，我们需要自己实现他们。然而使用Jekyll我们可以使用markdown或者Html编写页面，在本机预览并通过Git推送到GitHub Pages上托管，无需数据库 如果嫌麻烦，可以试试JekyllBootstrap，虽然貌似很久之前原作者就不再更新，不过看上去有人接手了后续本版本的开发(0.4.0 - next release [ETA 03/29/2015])。本博客则fork自barryclark/jekyll-now]]></content>
    </entry>

    
  
  
</search>
