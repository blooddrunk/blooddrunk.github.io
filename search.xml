<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Cancelable Promise]]></title>
      <url>%2F2017%2F02%2F06%2FCancelable-Promise%2F</url>
      <content type="text"><![CDATA[使用React时难免会需要在异步操作返回时调用setState()，如果此时该Component已经Unmount, React会抛出类似下面的错误： “Warning: setState(…): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op. Please check the code for the ContactPage component.” 解决这个问题最简单的方法就是在Lifecyle事件中手动设置并在调用setState()前检查某个标记位： inside a component123456789101112componentDidMount() &#123; this._isMounted = true&#125;componentWillUnmount() &#123; this._isMounted = false&#125;// 调用setState时if(this._isMounted) &#123; this.setState(...)&#125; 介于现在普遍都在使用Fetch API和Promise，更好的办法是使用可被Cancel的Promise，一个简单的实现如下： cancelable promise12345678910111213141516171819const makeCancelable = (promise) =&gt; &#123; let hasCanceled_ = false const wrappedPromise = new Promise((resolve, reject) =&gt; &#123; promise.then((val) =&gt; hasCanceled_ ? reject(&#123;isCanceled: true&#125;) : resolve(val) ) promise.catch((error) =&gt; hasCanceled_ ? reject(&#123;isCanceled: true&#125;) : reject(error) ) &#125;); return &#123; promise: wrappedPromise, cancel() &#123; hasCanceled_ = true; &#125;, &#125;&#125; 通过在原来返回Promise的调用外包裹一层Higher Order Function(虽然实际上返回的是一个新的对象), 然后在必要时(componentWillUnmount)取消掉: 12345678910const cancelablePromise = makeCancelable( new Promise(r =&gt; component.setState(&#123;...&#125;&#125;)));cancelablePromise .promise .then(() =&gt; console.log('resolved')) .catch((reason) =&gt; console.log('isCanceled', reason.isCanceled));cancelablePromise.cancel(); // Cancel the promise Eric Elliott大神给出了更完善的实现: https://github.com/ericelliott/speculation]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用React Motion在React中实现淡入/淡出效果]]></title>
      <url>%2F2017%2F01%2F01%2FUse-React-Motion-for-Fade-in-out-effects-in-React%2F</url>
      <content type="text"><![CDATA[直到我尝试用React实现一个简单的淡入淡出动画，我才怀念起jQuery。 React Motion是一个出色的React动画库，然而用它来实现单个组件的淡入/淡出，也不是很直观，下面是一个例子]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用CSS实现三角形]]></title>
      <url>%2F2016%2F12%2F23%2FCSS-Triangle%2F</url>
      <content type="text"><![CDATA[将一个盒子的宽和高都设为0，这样它的实际宽和高将由border确定，利用将两边的border-color设为transparent，中间的border的可见颜色区域将形成一个三角形 所以为何不用SVG…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于Javascript的变量提升(Hoisting)]]></title>
      <url>%2F2016%2F12%2F07%2FSomething-About-Hoising-in-Javascript%2F</url>
      <content type="text"><![CDATA[var vs let http://stackoverflow.com/questions/762011/whats-the-difference-between-using-let-and-var-to-declare-a-variable 主要区别在于作用域。var声明的变量的作用域为最近函数作用域，let声明的变量仅当前的块级作用域有效。 全局作用域定义在全局时，var和let表现的非常相似 12let a = 'foo'; // globally scopedvar b = 'bar'; // globally scoped 然而，与var不同，let定义在全局的变量不会成为window对象的一个属性 12console.log(window.a); // undefinedconsole.log(window.b); // 'bar' 重复声明在严格模式下，var可以在当前作用域下重复声明同一变量，let则不可以 123456789'use strict';let a = 'foo';let a = 'bar'; // SyntaxError: Identifier 'me' has already been declared...'use strict';var b = 'foo';var b = 'bar'; // No problem, `bme` is replaced. let/const声明的变量不会被提升？ http://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6?rq=1 实际上，javascript中所有的声明(var, let, const, function, function*, class)都会被提升。所以可以说，如果在某个作用域中定义一个变量，那么这个变量总是指向其在该作用域中的值。在函数作用域和块作用域中都是如此 12345678910111213x = "global";// function scope:(function() &#123; x; // not "global" var/let/… x;&#125;());// block scope (not for `var`s):&#123; x; // not "global" let/const/… x;&#125; var/function/function*和let/const/class声明的区别在于初始化。前者在’绑定(binding)’创建时，在作用域的最顶端被初始化为undefined；而后者并未被初始化，因此当你试图访问它时会抛出ReferenceError异常。只有代码执行到let/const/class语句本身时初始化才发生，从作用域顶端(提升的位置)到let/const/class声明被执行到之前之间的这个语法上的区域，被称为temporal dead zone let vs const 在变量提升上，let和const表现的完全一致，两者的唯一区别在于const能切仅能在初始化时被赋值一次。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一些前端面试的资源]]></title>
      <url>%2F2016%2F10%2F23%2FFront-end-Interview-Resources%2F</url>
      <content type="text"><![CDATA[随便收集了些前端面试的问题，没想到也是各种祖传背书题？Doctype, float, IE quirks乱七八糟的吓死了。Google/stackoverflow党压力山大。 中文: https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions https://github.com/h5bp/Front-end-Developer-Interview-Questions/tree/master/Translations/Chinese https://github.com/hawx1993/Front-end-Interview-questions 英文: https://github.com/khan4019/front-end-Interview-Questions https://github.com/h5bp/Front-end-Developer-Interview-Questions https://frontendmasters.gitbooks.io/front-end-handbook-2017/content/practice/interview-q.html Eric Elliott的系列文章(国内貌似有翻译的): Master the JavaScript Interview: What is a Closure? Master the JavaScript Interview: What’s the Difference Between Class &amp; Prototypal Inheritance? Master the JavaScript Interview: What is a Pure Function? Master the JavaScript Interview: What is Function Composition? Master the JavaScript Interview: What is Functional Programming? Master the JavaScript Interview: What is a Promise?]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redux 'ducks' 文件组织结构]]></title>
      <url>%2F2016%2F10%2F10%2Fredux-ducks-file-structure%2F</url>
      <content type="text"><![CDATA[https://github.com/erikras/ducks-modular-redux 传统上，一个react/redux项目会有类似以下的目录 123456|_ containers|_ components|_ reducers|_ actions|_ constants|_ ... 然而对于不太复杂的项目，很多情况下我们只需要用到一两个reducer和action(creator)，上面的目录结构由于将逻辑上的功能分散使得import有些繁琐。以下按模块划分的Ducks目录结构更直观 widgets.js123456789101112131415161718192021222324252627282930// Actionsconst LOAD = 'my-app/widgets/LOAD';const CREATE = 'my-app/widgets/CREATE';const UPDATE = 'my-app/widgets/UPDATE';const REMOVE = 'my-app/widgets/REMOVE';// Reducerexport default function reducer(state = &#123;&#125;, action = &#123;&#125;) &#123; switch (action.type) &#123; // do reducer stuff default: return state; &#125;&#125;// Action Creatorsexport function loadWidgets() &#123; return &#123; type: LOAD &#125;;&#125;export function createWidget(widget) &#123; return &#123; type: CREATE, widget &#125;;&#125;export function updateWidget(widget) &#123; return &#123; type: UPDATE, widget &#125;;&#125;export function removeWidget(widget) &#123; return &#123; type: REMOVE, widget &#125;;&#125; 约定 一个所谓模块， 必须export default一个叫reducer()的函数(也就是我们的reducer) 必须export它的action creators函数 以类似npm-module-or-app/reducer/ACTION_TYPE的方式定义他的action type 如果必要，也export它的action type]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript Object对象中一些容易混淆的方法]]></title>
      <url>%2F2016%2F09%2F28%2FSimilar-Methods-in-Javascript-Object%2F</url>
      <content type="text"><![CDATA[Object.is() vs ===与===不同，Object.is()认为+0和-0不相等，而两个NaN值相等。 12345Object.is(0, -0); // false+0 === -0; // trueObject.is(NaN, 3/0); // trueNaN === Number.NaN; // false Object.keys() vs Object.getOwnPropertyNames()两者都只会返回自身的属性，不同之处在于Object.keys()只会返回可枚举(enumerable)的属性，而Object.getOwnPropertyNames()还会返回不可枚举的属性。 只返回不可枚举的属性12345678910111213var target = myObject;var enum_and_nonenum = Object.getOwnPropertyNames(target);var enum_only = Object.keys(target);var nonenum_only = enum_and_nonenum.filter(function(key) &#123; var indexInEnum = enum_only.indexOf(key); if (indexInEnum == -1) &#123; // not found in enum_only keys mean the key is non-enumerable, // so return true so we keep this in the filter return true; &#125; else &#123; return false; &#125;&#125;); Object.seal() vs Object.freeze() vs Object.preventExtension()Object.preventExtension(): 返回一个新的对象，该对象不能添加新的属性。 Object.seal(): 返回一个新的对象，除了不能添加新的属性之外，所有已有的属性都会被标记为“不可配置”的(见Object.defineProperty())，也就是说所有的属性都不能被删除，但是如果某个属性的描述符已被配置为writable，该属性的值还是可以被修改。 Object.freeze(): 同Object.seal()一样。除了新返回的对象的所有属性都不能被修改(non-writable)。 Object.isExtensible(), Object.isSealed()和Object.isFrozon()可分别用于检测一个对象是否由上面的方法生成 ‘sealed’或’frozon’的对象自然也是non-extensible的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP状态码一览]]></title>
      <url>%2F2016%2F09%2F06%2FHTTP-State-Codes%2F</url>
      <content type="text"><![CDATA[http://www.restapitutorial.com/httpstatuscodes.html 一些常见的HTTP状态码 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 200 OK 正常返回信息201 Created 请求成功并且服务器创建了新的资源202 Accepted 服务器已接受请求，但尚未处理301 Moved Permanently 请求的网页已永久移动到新位置。302 Found 临时性重定向。303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。304 Not Modified 自从上次请求后，请求的网页未修改过。 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。401 Unauthorized 请求未授权。403 Forbidden 禁止访问。404 Not Found 找不到如何与 URI 相匹配的资源。 500 Internal Server Error 最常见的服务器端错误。503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 详细列表： 1**(信息类)：表示接收到请求并且继续处理 100——客户必须继续发出请求 101——客户要求服务器根据请求转换HTTP协议版本 2**(响应成功)：表示动作被成功接收、理解和接受 200——表明该请求被成功地完成，所请求的资源发送回客户端 201——提示知道新文件的URL 202——接受和处理、但处理未完成 203——返回信息不确定或不完整 204——请求收到，但返回信息为空 205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件 206——服务器已经完成了部分用户的GET请求 3**(重定向类)：为了完成指定的动作，必须接受进一步处理 300——请求的资源可在多处得到 301——本网页被永久性转移到另一个URL 302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。 303——建议客户访问其他URL或访问方式 304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用 305——请求的资源必须从服务器指定的地址得到 306——前一版本HTTP中使用的代码，现行版本中不再使用 307——申明请求的资源临时性删除 4**(客户端错误类)：请求包含错误语法或不能正确执行 400——客户端请求有语法错误，不能被服务器所理解 401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 HTTP 401.1 - 未授权：登录失败 HTTP 401.2 - 未授权：服务器配置问题导致登录失败 HTTP 401.3 - ACL 禁止访问资源 HTTP 401.4 - 未授权：授权被筛选器拒绝 HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败 402——保留有效ChargeTo头响应 403——禁止访问，服务器收到请求，但是拒绝提供服务 HTTP 403.1 禁止访问：禁止可执行访问 HTTP 403.2 - 禁止访问：禁止读访问 HTTP 403.3 - 禁止访问：禁止写访问 HTTP 403.4 - 禁止访问：要求 SSL HTTP 403.5 - 禁止访问：要求 SSL 128 HTTP 403.6 - 禁止访问：IP 地址被拒绝 HTTP 403.7 - 禁止访问：要求客户证书 HTTP 403.8 - 禁止访问：禁止站点访问 HTTP 403.9 - 禁止访问：连接的用户过多 HTTP 403.10 - 禁止访问：配置无效 HTTP 403.11 - 禁止访问：密码更改 HTTP 403.12 - 禁止访问：映射器拒绝访问 HTTP 403.13 - 禁止访问：客户证书已被吊销 HTTP 403.15 - 禁止访问：客户访问许可过多 HTTP 403.16 - 禁止访问：客户证书不可信或者无效 HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效 404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL 405——用户在Request-Line字段定义的方法不允许 406——根据用户发送的Accept拖，请求资源不可访问 407——类似401，用户必须首先在代理服务器上得到授权 408——客户端没有在用户指定的饿时间内完成请求 409——对当前资源状态，请求不能完成 410——服务器上不再有此资源且无进一步的参考地址 411——服务器拒绝用户定义的Content-Length属性请求 412——一个或多个请求头字段在当前请求中错误 413——请求的资源大于服务器允许的大小 414——请求的资源URL长于服务器允许的长度 415——请求资源不支持请求项目格式 416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段 417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。 5**(服务端错误类)：服务器不能正确执行一个正确的请求 HTTP 500 - 服务器遇到错误，无法完成请求 HTTP 500.100 - 内部服务器错误 - ASP 错误 HTTP 500-11 服务器关闭 HTTP 500-12 应用程序重新启动 HTTP 500-13 - 服务器太忙 HTTP 500-14 - 应用程序无效 HTTP 500-15 - 不允许请求 global.asa Error 501 - 未实现 HTTP 502 - 网关错误 HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[debounce vs throttle]]></title>
      <url>%2F2016%2F08%2F16%2Fdebounce-vs-throttle%2F</url>
      <content type="text"><![CDATA[https://css-tricks.com/debouncing-throttling-explained-examples/ Debounce和Throttle是用来控制一段时间内某个函数执行次数的类似但不相同的两种技巧。如果你曾想要控制一个scroll事件的触发频率，你很可能考虑过到底该用两者中的哪一个。 简单来说： debounce 将短时间内突然大量爆发的重复事件(比如键盘点击)限制为一个 throttle 保证函数每N毫秒固定执行一次。比如每200ms检查一次页面滚动的位置来触发一个CSS动画 在某些情况下，requestAnimationFrame可发挥和throttle类似的作用，比如你要执行的函数用来计算并在屏幕上呈现某些元素，使用requestAnimationFrame可以实现更平滑的变化(动画) Debounce1_.debounce(func, [wait=0], [options=&#123;&#125;]) 按照Lodash的解释，Debounce将一个函数(func)的调用推迟到自它上次该Debounced函数被调用后的某个时间(wait)后。 12345678910111213141516// Avoid costly calculations while the window size is in flux.jQuery(window).on('resize', _.debounce(calculateLayout, 150)); // Invoke `sendMail` when clicked, debouncing subsequent calls.jQuery(element).on('click', _.debounce(sendMail, 300, &#123; 'leading': true, 'trailing': false&#125;)); // Ensure `batchLog` is invoked once after 1 second of debounced calls.var debounced = _.debounce(batchLog, 250, &#123; 'maxWait': 1000 &#125;);var source = new EventSource('/stream');jQuery(source).on('message', debounced); // Cancel the trailing debounced invocation.jQuery(window).on('popstate', debounced.cancel); 想象你正在一个电梯中，在电梯门正要关上的时候，另外一个人想要冲进电梯。电梯不会开始运动，而是再次打开门，这个过程会重复直到不再有人想要闯入电梯为止。如果之前Debounced函数并没被执行过，那么被延迟的事件就不会被执行。幸运的是，Debounce(Lodash的实现)有个maxWait的配置项控制函数能被延迟执行的最大间隔。 回到最上面的例子，看看用Debounce的效果，连续滚动，数字只会在滚动停止后的200ms后执行一次。Debounce在这个例子中显然不合适（虽然设置maxWait可以解决这个问题)。但是却适合用于resize的场合，因为往往我们只知道resize发生了就够了。 http://stackoverflow.com/questions/24079736/confused-about-the-maxwait-option-for-lodashs-debounce-method scroll: resize(在新窗口中打开来看效果): Throttle1_.throttle(func, [wait=0], [options=&#123;&#125;]) Throttle则要好理解很多。Throttle确保一个函数(func)在一段时间(wait)内至多被调用一次 123456789// Avoid excessively updating the position while scrolling.jQuery(window).on('scroll', _.throttle(updatePosition, 100)); // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.var throttled = _.throttle(renewToken, 300000, &#123; 'trailing': false &#125;);jQuery(element).on('click', throttled); // Cancel the trailing throttled invocation.jQuery(window).on('popstate', throttled.cancel); 最上面的例子用Throttle来实现，是不是正是我们想要的效果 requestAnimationFrame使用requestAnimationFrame来实现经过浏览器优化的、更省电的动画效果。此外，在不活动的标签页的调用会被暂停以节省资源。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Hexo静态博客引擎在GitHub pages上搭建博客]]></title>
      <url>%2F2016%2F07%2F22%2FSetup-a-Blog-on-Github-Pages-with-Hexo%2F</url>
      <content type="text"><![CDATA[前提要求: Git, Node 参考Hexo文档初始化一个博客目录假设名为yourname 1234$ hexo init yourname$ cd yourname$ npm i$ git init (可选) 安装并启用一个主题NexT是个不错的选择 1$ git submodule add https://github.com/iissnan/hexo-theme-next themes/next 别忘了修改配置启用主题 以后只要该主题有更新，定位至主题目录pull即可 创建一个GitHub Repo在Github上创建一个新的仓库，名为username.github.io，其中username是你的GitHub用户名 部署安装hexo-deployer-git 12# 在你的博客根目录中$ npm i hexo-deployer-git --S 修改站点的_config.yml配置，新增deploy节： 12345deploy: type: git repo: &#123;your-git-repo-url&#125; branch: master message: "Site updated: &#123;&#123; now('YYYY-MM-DD HH:mm:ss') &#125;&#125;" 部署： 1234# 也许先写点什么$ hexo new &#123;postname&#125;# ...$ hexo g -d (可选)推送源代码到GitHubhexo-deployer-git推送编译好的静态博客，为了更好维护源码，创建一个新的分支推送到远程仓库中 1234$ git remote add origin &#123;your-git-repo-url&#125;$ git checkout -b source # add and commit...$ git push origin source 你以后可以留在source进行开发，使用hexo g -d推送博客到master]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用CSS给图片着色以突出文本]]></title>
      <url>%2F2016%2F06%2F22%2FText-On-Image%2F</url>
      <content type="text"><![CDATA[使用position可以简单的在图片上覆盖文字，同时，为了更好的突出文字，往往希望让图片变暗，使用CSS一个元素可以有多个background的特性，可以轻松实现这个效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS属性顺序惯例]]></title>
      <url>%2F2016%2F04%2F13%2FCSS-Properties-Ordering%2F</url>
      <content type="text"><![CDATA[CSS的style guide有很多，重度强迫症也许对属性的排序也有要求，大部分人倾向于按类型/重要性排序， 比如按下面的分类来排序(分组)： Layout Properties (position, float, clear, display) Box Model Properties (width, height, margin, padding) Visual Properties (color, background, border, box-shadow) Typography Properties (font-size, font-family, text-align, text-transform) Misc Properties (cursor, overflow, z-index) 123456789101112131415161718192021222324252627282930.selector &#123; /* Positioning */ position: absolute; z-index: 10; top: 0; right: 0; /* Display &amp; Box Model */ display: inline-block; overflow: hidden; box-sizing: border-box; width: 100px; height: 100px; padding: 10px; border: 10px solid #333; margin: 10px; /* Color */ background: #000; color: #fff; /* Text */ font-family: sans-serif; font-size: 16px; line-height: 1.4; text-align: right; /* Other */ cursor: pointer;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[边距塌陷(组合) margin collapse]]></title>
      <url>%2F2016%2F02%2F09%2Fmargin-collapse%2F</url>
      <content type="text"><![CDATA[块元素的上/下边距有时会塌陷(组合)成一个单的的边距，实际的边距大小是两个边距中值最大的一个，这就是所谓的margin collapsing 最常见的情况出现在上下相邻的两个元素，如下，虽然上面的div有25px的下边距，但由于下面的div的上边距为50px，所以两者的实际间距为50px]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[(面试传家宝)在浏览器中输入一个URL之后发生了什么]]></title>
      <url>%2F2015%2F12%2F08%2Fwhat-happens-when-you-enter-a-url-in-browser%2F</url>
      <content type="text"><![CDATA[http://stackoverflow.com/questions/2092527/what-happens-when-you-type-in-a-url-in-browser# https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers 详细版： 浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理; 调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法; 通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求; 进行HTTP协议会话，客户端发送报头(请求报头); 进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器; 进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理; 处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304; 浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存; 文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie; 页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。 简洁版： 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求； 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）； 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）； 载入解析到的资源文件，渲染页面，完成。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[box-sizing reset]]></title>
      <url>%2F2015%2F07%2F13%2Fbox-sizing-reset%2F</url>
      <content type="text"><![CDATA[在网站中使用border-box的box-sizing可以简化我们计算元素布局尺寸时的工作，下面是一种较为流行的reset做法 123456html &#123; box-sizing: border-box;&#125;*, *:before, *:after &#123; box-sizing: inherit;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift 1.2中类的可失败构造方法]]></title>
      <url>%2F2015%2F05%2F10%2FSwift-Failable-Initializer%2F</url>
      <content type="text"><![CDATA[在Swift的构造函数中可以通过return nil来表示构造过程可能失败，如下： 123456789struct EvenNumberStruct &#123; let number: UInt init?(number: UInt) &#123; if number % 2 != 0 &#123; return nil &#125; self.number = number &#125; &#125; 然而如把上面的结构换成类，就会得到下面的错误: 1All stored properties of a class instance must be initialized before returning nil from an initializer 这是因为类的可失败构造函数只有在所有的类属性被初始化完成后才会触发失败行为，也就是说，在return nil之前，须保证所有的存储属性已被初始化（虽然我们的本意就是在这种情况下不必进行初始化）。在Swift 1.1中，可以将上边的存储属性改为可选类型，这样它就有一个默认的初始值nil。然而Swift 1.2中，改为UInt!并不会解决问题，事实上，只要把self.number = number放在return nil前面即可。 123456789101112131415class EvenNumber &#123; let number: UInt init?(number: UInt) &#123; self.number = number // 在我测试的XCode 6.3.1中，这段代码必须在return nil之前 if number % 2 != 0 &#123; return nil &#125; &#125; private init(num: UInt) &#123; self.number = num &#125; class func defaultNumber() -&gt; EvenNumber &#123; return EvenNumber(num: 2) &#125;&#125; 需要注意的是，对于常量属性，也就是用let声明的属性，必须确保这个属性在return nil之前，在所有可能的执行路径中都被初始化。如下代码会报variable ‘self.number’ used before initialized这样不知所云的错误 lang: swift123456789101112131415161718class EvenNumber &#123; let number: UInt! init?(number: UInt) &#123; if number &gt; 1 &#123; self.number = number &#125; if number % 2 != 0 &#123; return nil &#125; &#125; private init(num: UInt) &#123; self.number = num &#125; class func defaultNumber() -&gt; EvenNumber &#123; return EvenNumber(num: 2) &#125;&#125; 这可能跟Swift 1.2中的另一点改动有关：在一个构造函数中，常量属性只能被赋值一次，这意味着我们不再能在常量属性声明时赋予它一个初始值，然后在构造函数中覆盖它。（但同样由于Swift 1.2 的最新改动，我们可以先声明一个常量变量，只需保证在第一次使用它之前唯一的赋予它一个初始值即可。）把let改为var可解决上述问题，或者确保number在return nil前完全被初始化： 12345678910111213141516171819class EvenNumber &#123; let number: UInt! init?(number: UInt) &#123; if number &gt; 0 &#123; self.number = number &#125; else &#123; self.number = 0 &#125; if number % 2 != 0 &#123; return nil &#125; &#125; private init(num: UInt) &#123; self.number = num &#125; class func defaultNumber() -&gt; EvenNumber &#123; return EvenNumber(num: 2)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS应用程序生命周期]]></title>
      <url>%2F2015%2F04%2F27%2FIOS-Application-Lifecycle%2F</url>
      <content type="text"><![CDATA[iOS app主要有五个状态，Not running, Inactive, Active, Background, Suspended。它们之间的转换关系如下： 状态 说明 Not running app尚未被启动或者被用户或系统终止 Inactive app正在前台运行但是尚未开始接受UI事件（但它可能在执行其他代码）。一个app通常只在这个状态停留一段短暂的时间，然后转换到下个状态。在进入inactive状态时，由于马上就会过渡到background或active状态，app此时应该让自己保持不活动的状态。 Active app正在前台运行并在接受事件。这就是我们通常看到的前台程序的状态。一个处于active状态的app没有特殊的限制，它应当对用户操作做出响应。 Background app正在执行代码但没有显示在屏幕上。当用户退出一个app时，系统在中止这个app之前（进入suspended状态）使它短暂的置于background状态。在其他情况下，系统可能在后台启动某个app（或者唤醒一个处于suspended状态的app），给它一定时间来处理某些特定的任务。比如，系统可能唤醒一个app让它来进行后台下载，处理和位置的有关的事件，远程通知或其他类型的事件。处于background状态的app应当做的工作越少越好，它应该尽快把控制还给系统。 Suspended app还在内存中但没有在执行任何代码。系统会中止那些没有任何挂起的任务要完成的后台程序。系统可能在任何时候清理这些程序来为其他app提供空间。 启动某个app：not running -&gt; inactive -&gt; active 从一个app切换到另一个app：active -&gt; inactive -&gt; background -&gt; suspended AppDelegate.swiftXcode自动提供的AppDelegate类（实现了UIApplicationDelegate接口）包含这个app的启动代码和app生命周期的重要状态变化。简单介绍一下状态发生变化会被调用的重要方法： Not running -&gt; Inactive12optional func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject : AnyObject]?) -&gt; Bool launchOptions参数是一个包括了app被启动原因的字典（直接被用户启动的情况下可能为空） 也可以监视UIApplicationDidFinishLaunchingNotification系统通知实现相同的功能。 Active -&gt; Inactive1optional func applicationWillResignActive(_ application: UIApplication) 可以在这里暂停UI活动 Inactive -&gt; Active1optional func applicationDidBecomeActive(_ application: UIApplication) 也可以监视UIApplicationWillResignActiveNotification通知 Inactive -&gt; Background1optional func applicationDidEnterBackground(_ application: UIApplication) 在这个方法中释放共享资源，保存当前的应用程序状态（因为稍后它有可能被系统终止） 这个方法只有大概5秒的时间来执行相关任务。如果需要额外的时间来执行一些重要的清理的工作，调用beginBackgroundTaskWithExpirationHandler（比如将一些重要的信息传送到远程主机上），但它不应当用来简单的延长程序在后台的执行。通常在applicationDidEnterBackground中执行的任务越少越好。 也可以监视UIApplicationDidEnterBackgroundNotification通知 Background -&gt; Inactive1optional func applicationWillEnterForeground(_ application: UIApplication) app从后台重新回到前台，可以在这里撤销在app进入Background时做的一些工作。 也可以监视UIApplicationWillEnterForegroundNotification通知]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift中的NSNotification]]></title>
      <url>%2F2015%2F04%2F20%2FSwift-NSNotification%2F</url>
      <content type="text"><![CDATA[NSNotification提供了在应用程序中广播和接受消息的方法。 注册一个通知注册一个通知非常简单，获取默认的“通知中心”，然后调用addObserverForName方法 比如，监视用户在设置中改变字体的通知： 123456789101112let center = NSNotificationCenter.defaultCenter() // 获取用于系统通知的通知中心center.addObserverForName(UIContentSizeCategoryDidChangeNotification // 要监视的通知的名称 object: UIApplication.sharedApplication(), // 要见识的通知发送者(nil表示所有发送者) queue: NSOperationQueue.mainQueue()) // 用于执行接收到通知后要执行的闭包的队列&#123; notification in // 这其实是个trailing闭包，是第四个参数 // ... let c = notification.userInfo?[UIContentSizeCategoryNewValueKey] // 获取设置的新的字体，比如UIContentSizeCategorySmall // userInfo是随通知发送的包含相关信息的字典&#125; 创建一个通知除了监听系统通知，我们自己也可以创建通知 1234567let center = NSNotificationCenter.defaultCenter() // 获取用于系统通知的通知中心let notification = NSNotification(name: GPXURL.Notification, object: self, userInfo: [GPXURL.Key:url]) // 创建一个通知center.postNotification(notification) // 发送通知 然后我们就可以根据创建NSNotification是提供的参数(name和object)来监视这个通知了，并可以取得创建时提供的userInfo字典]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift的初始化限制导致的头痛问题]]></title>
      <url>%2F2015%2F04%2F15%2FSwift-Initialization-Trap%2F</url>
      <content type="text"><![CDATA[Swift在它的两步式构造过程中有严格的安全检查来保证构造的顺利进行，但这些初看上去有点晕的限制让我在初始化类自身的属性时费了不少劲。不是Property &#39;self.xx&#39; not initialized at super.init call，就是use of property &#39;xx&#39; in base object before super.init initializes it 先来复习一下Swift两步式构造过程的规则: 阶段1 某个指定构造器或便利构造器被调用； 完成新实例内存的分配，但此时内存还没有被初始化； 指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化； 指定构造器将调用父类的构造器，完成父类属性的初始化； 这个调用父类构造器的过程沿着构造器链一直往上执行，直到到达构造器链的最顶部； 当到达了构造器链最顶部，且已确保所有实例包含的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段1完成。 阶段2 从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问self、修改它的属性并调用实例方法等等。 最终，任意构造器链中的便利构造器可以有机会定制实例和使用self。 也就是说，在调用父类构造器前，必须先完成自身属性的初始化： 1234567891011class ViewController: UIViewController &#123; private let animator: UIDynamicAnimator required init(coder aDecoder: NSCoder) &#123; // ERROR: Property 'self.animator' not initialized at super.init call super.init(coder: aDecoder) animator = UIDynamicAnimator(referenceView: self.view) &#125;&#125; 然而，在父类的初始化过程完成前，也无法在子类中使用self.view，交换上面两行代码顺序后还是报错： 1234567891011class ViewController: UIViewController &#123; private let animator: UIDynamicAnimator required init(coder aDecoder: NSCoder) &#123; // use of property 'view' in base object before super.init initializes it animator = UIDynamicAnimator(referenceView: self.view) super.init(coder: aDecoder) &#125;&#125; 在一些情况下，我们可以把初始化分为两步来解决问题，不过在这里UIDynamicAnimator.referenceView是个只读属性，并不能奏效： 123456789101112class ViewController: UIViewController &#123; private let animator: UIDynamicAnimator required init(coder aDecoder: NSCoder) &#123; animator = UIDynamicAnimator() // 先不引用self super.init(coder: aDecoder) // ERROR: Cannot assign to the result of this expression animator.referenceView = self.view // 等父类构造过程完成 &#125;&#125; 更好一点的方式，将这个属性改为Optional，并确保它在较早的阶段(构造完成后)被赋值(比如viewDidLoad)： 1234567891011121314class ViewController: UIViewController &#123; private var animator: UIDynamicAnimator! // 使用隐式解包可选属性可以避免以后每次使用时显示解包的麻烦 required init(coder aDecoder: NSCoder) &#123; super.init(coder: aDecoder) &#125; override func viewDidLoad() &#123; super.viewDidLoad() animator = UIDynamicAnimator(referenceView: self.view) &#125;&#125; 此外，还可以使用延迟存储属性和立即执行的闭包(不使用闭包依然无法在此时使用self)： 1234567891011121314151617class ViewController: UIViewController &#123; // 延迟属性必须用var声明 lazy private var animator: UIDynamicAnimator = &#123; return UIDynamicAnimator(referenceView: self.view) &#125;() required init(coder aDecoder: NSCoder) &#123; super.init(coder: aDecoder) &#125; override func viewDidLoad() &#123; super.viewDidLoad() animator.addBehavior(UIGravityBehavior()) &#125;&#125; 这种方法的缺点是使用延迟属性的话就无法使用属性观察器了 我现在碰到的问题是，想在一个UIView的属性的didSet中调用setNeedsDisplay()，同时它的初始值构造时要用到self.bounds，因此无法使用延迟属性。使用可选值的话，又不知道如何在UIView中合理的给它一个初始值。烦。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift中的"toString"方法]]></title>
      <url>%2F2015%2F03%2F31%2FToString-in-Swift%2F</url>
      <content type="text"><![CDATA[在Swift为对象实现类似toString的方法非常简单：在相应的类、结构或枚举声明中实现Printable协议，然后实现该协议指定的description只读计算属性即可： 12345678910111213struct Rect: Printable &#123; var width: Double var height: Double var description: String &#123; return "width=\(width), height=\(height)" &#125;&#125;let r = Rect(width: 11, height: 22)println("My Rect: \(r)") 在playground中不知道为什么在右侧看到的结果跟没有实现Printable协议一样，这应该是playground的问题]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用Swift语言开发iOS8 App： Multiple MVC]]></title>
      <url>%2F2015%2F03%2F30%2FDeveloping-iOS-8-Apps-with-Swift-Multiple-MVCs%2F</url>
      <content type="text"><![CDATA[iOS有一些内置Controller，它们的视图是另一个MVC：UITabBarController, UISplitViewController, UINavigationController, UIPopoverController UITabBarController UITabBarController绘制在屏幕下方绘制了最多5个tab标签(如果超过5个会自动呈现一个管理超出部分的界面)，上方呈现当前选定的tab的MVC。事实上，下方的tab栏的icon, title都是由UITabBarController包含的MVC的Controller的 123var tabBarItem: UITabBarItem! 属性所决定。tar bar item通常在storyboard中拖放进来。 UISplitViewController UISplitViewController只包括两个MVC：通常左侧Master决定了右侧的Detail的内容(每次都会生成一个新的Detail)。只有在iPad和iPhone6+的横屏模式可以同时显示Master和Detail，在iPad竖屏时只显示Detail，滑动屏幕才能看到Master。在其他尺寸的设备中需要嵌入UINavigationController来让UISplitViewController正常工作，这是由Size Classes决定的 UINavigationController UINavigationController大量运用于“设置”菜单中。可以把它想象成一个后进先出的Stack，最初的元素叫做rootViewController，最上面的元素叫做visibleViewController，它们都是UINavigationController的属性，每当在当前设置页面中点击一个子项，就相当于在上面push一个新项，而每点一次“后退”，就会把最上边的项pop掉(完全丢弃)。UINavigationController只负责呈现了上方的标题栏，下方的内容由Stack最上方的MVC所决定。甚至标题的内容，和标题栏的按钮也是由当前显示的MVC决定的(navigationItem属性)。 获得子MVCUITabBarController, UISplitViewController, UINavigationController都一个数组属性表示它们包含的子MVC 123var viewControllers: [UIViewController] &#123; get set &#125; 相反的，每一个UIViewController也有三个对应的属性表示它是否在UITabBarController, UISplitViewController, UINavigationController中 12345678910var tabBarController: UITabBarController? &#123; get &#125;var splitViewController: UISplitViewController? &#123; get &#125;var navigationController: UINavigationController? &#123; get &#125;//在Master中获得Detailif let detailVC = splitViewController?.viewControllers[1] &#123; ...&#125; Segue创建好了子MVC后，我们还需要调用它们，这就是Segue，主要有以下几种Segue： Show Segue(如果在UINavigationController中，被调用的MVC就会被添加进UINavigationController的顶端，否则会展示为Modal窗口) Show Detail Segue(如果在UISplitViewController中，会展示一个Detail MVC，否则类似Show Segue) Modal Segue(展示为模态窗口，不太会用到) Popover Segue(展示为一个popover窗口，点击窗口以外的区域就会关闭该窗口) Segue每次都会创建一个新的MVC，旧的会被抛弃 在storyboard中建立好Segue关系(通常是通过Control/右键拖动，比如在调用MVC中的一个按钮到目标MVC，点击这个按钮就会展示目标MVC)并填写好Segue的id后，往往还需要为目标MVC提供一定的初始化数据，为此在调用MVC中overrideprepareForSegue方法： 1234567891011121314func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) &#123; if let identifier = segue.identifier &#123; switch identifier &#123; case “Show Graph”: if let vc = segue.destinationViewController as? CalcGraphController &#123; vc.property1 = ... vc.callMethodToSetItUp(...) &#125; default: break &#125; &#125;&#125; 第一个参数segue有两个重要的属性，第一个是identifier(在storyboard的Attribules inspector中设置），用来标识调用了哪个Segue，另一个destinationViewController表示目标MVC，可利用它暴露的借口来做一些初始化工作，注意它是AnyObject，需要转换类型 需要注意的是，prepareForSegue执行的时候，destinationViewController中的outlets并没有被初始化，需要避免假设outlets有值而引发异常]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用Swift语言开发iOS8 App： 生命周期]]></title>
      <url>%2F2015%2F03%2F30%2FDeveloping-iOS-8-Apps-with-Swift-Lifecycle%2F</url>
      <content type="text"><![CDATA[一个View Controller的生命周期中会调用一系列方法，我们常常需要override这些方法来实现某些功能。 初始化(通常是从storyboard开始) awakeFormNib(每一个来自storyboard的对象都会调用这个方法，包括Controller） prepareForSegue(为segue做一些准备工作) outlet获得值(这意味着在prepareForSegue时，destinationViewController的outlet还没有值) viewDidLoad(最常用的放置初始化代码的地方) viewWillAppear viewDidAppear(view出现时调用，可能会调用多次) viewWillDisappear viewDidDisappear(view消失时调用，可能会调用多次) viewWillLayoutSubviews viewDidLayoutSubviews(当一个view的frame改变，需要重新布局时调用，比如呈现、旋转，autolayout发生在”will”和”did”之间) didReceiveMemoryWarning(内存不足，非常罕见的情况)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用Swift语言开发iOS8 App： View]]></title>
      <url>%2F2015%2F03%2F28%2FDeveloping-iOS-8-Apps-with-Swift-Views%2F</url>
      <content type="text"><![CDATA[Paul Hegary的Swift课程中关于View的一些笔记 1. view(UIView的子类)代表了一块方形区域，定义的一块坐标空间用于绘制和处理事件 2. 一个view只有一个父view 123var superview: UIView? 但可能有多个子view 123var subviews: [AnyObject] // 应转换为UIView类型 subviews属性数组中位置靠后的view位于位置靠前的view的上面 3. 以编程方式创建并添加view 12345superV.addSubView(aView: UIView)subV.removeFromSuperView() 4. 在UIViewController中有一个属性，它表示了当前视图中最顶层的view，我们通常就是向这个顶级view中添加子view 123var view: UIView 5. 坐标系统，CGFloat CGFloat CGSize CGRect 123456789let cfg = CGFloat(aDouble) // 坐标系统的单位总是CGFloatvar point = CGFloat(x: 37.0, y: 55.2)var size = CGSize(width: 100.0, height: 50.0)let rect = CGRect(origin: aCGPoint, size: aCGSize) 坐标的原点位于左上角 坐标的单位是point，view的contentScaleFactor属性表示一个point有几个像素(通常是2) view的bounds(CGRect)属性表示了它在自己的坐标系统的边界，因此bounds的origin默认为0, 0 view的center(CGPoint)属性表示了它的中心在父view中的坐标(使用convertToPoint获得center在当前view的坐标) 类似的，frame(CGRect)属性表示它在父view坐标系统中的矩形边界 6. 自定义view：新建一个UIView的子类并 overridedrawRect方法。 不要直接调用drawRect，使用setNeedsDisplay来间接调用它以实现重绘 实现drawRect： 12345678910111213let path = UIBezierPath()path.moveToPoint(CGPoint(80, 50)) // assume screen is 160x250path.addLineToPoint(CGPoint(140, 150))path.addLineToPoint(CGPoint(10, 150))path.closePath()UIColor.greenColor().setFill() // note this is a method in UIColor, not UIBezierPathUIColor.redColor().setStroke() // note this is a method in UIColor, not UIBezierPathpath.linewidth = 3.0 // note this is a property in UIBezierPath, not UIColor 7. 字体。通常使用以下类静态方法获取不同类型文本的字体，而不是指定固定的大小： 123456789101112class func preferredFontForTextStyle(UIFontTextStyle) -&gt; UIFont// 部分可用的styleUIFontTextStyle.HeadlineUIFontTextStyle.BodyUIFontTextStyle.Footnote// 指定大小的系统字体，不要在用户内容中使用它们class func systemFontOfSize(pointSize: CGFloat) -&gt; UIFontclass func boldSystemFontOfSize(pointSize: CGFloat) -&gt; UIFont 8. bounds改变时view的行为 123var contentMode: UIViewContentMode 不缩放view，只移动到某个位置.Left/.Right/.Top/.Bottom/.TopRight/.TopLeft/.BottomRight/.BottomLeft/.Center 缩放.ScaleToFill/.ScaleAspectFill/.ScaleAspectFit，.ScaleToFill是默认选项 再次调用drawRect，重绘.Redraw]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift的一些标准内置函数]]></title>
      <url>%2F2015%2F03%2F27%2FSwift-Standard-Functions%2F</url>
      <content type="text"><![CDATA[Swift有一些全局标准函数在The Swift Programming Language并没有提到。在Paul Hegary的Swift课程中看到一些，做下笔记。 1234567891011121314// Collections包括Array, Dictionary, String// Sliceables包括Array, Stringlet sub = dropFirst(aSliceable) // 返回一个去掉第一个元素的新序列let sub = dropLast(aSliceable) // 返回一个去掉最后一个元素的新序列let first = first(aCollection) // 返回序列的第一个元素(可选值)let last = last(aCollection) // 返回序列的最后一个元素(可选值)let prefix = prefix(aSliceable, X: Int) // 返回序列的前X个元素的子序列let suffix = suffix(aSliceable, X: Int) // 返回序列的后X个元素的子序列let reversed = reverse(aCollection) // 返回倒序的序列，注意返回值是一个数组let backwardsString = String(reverse(str)) // 返回字符串的倒序let isEqual = equal(aSliceable1, aSliceable2) // 检查两个序列是否相等 此外正如由于Unicode码元的原因应该用countElements来获取字符串的长度，在Swift中也无法简单的用Int来表示String的Index，取而代之的是String.Index，而使用Range&lt;String.Index&gt;来表示字符串片段 1234567var str = "hello"let start = str.startIndex // 获得字符串的第一个字符的位置let end = str.endIndex // 获得字符串的最后一个字符的位置let index = advance(str.startIndex, 2) // 获得字符串第三个字符的位置(第一个字符之后两个)let substring = str[index..&lt;end] // 获得子串 上面的提到了Range，它表示Swift中序列的一个片段，在for-in循环中已经隐式使用过它了： 123456var r: Range&lt;Int&gt; = 1...7 // 或者用1..&lt;8表示一个半闭区间for i in r &#123; println(i)&#125; 借助Range&lt;String.Index&gt;我们可以实现类似IndexOf的效果(不知道有没有简单的方法)： 123456var str = "Hello, playground"let commaIndex = str.rangeOfString(",")!.startIndex // 5let stringBeforeComma = str.substringToIndex(commaIndex) // "Hello"str.removeRange(commaIndex..&lt;str.endIndex) // str = "Hello"，参数相当于Range&lt;String.Index&gt;(start: commaIndex, end: str.endIndex)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用Pandoc将中文编码Markdown转换为PDF]]></title>
      <url>%2F2015%2F03%2F25%2FConvert-Mardown-In-Chinese-To-Pdf-Using-Pandoc%2F</url>
      <content type="text"><![CDATA[Pandoc是一款著名的文档格式的转换器。借助Pandoc可以使用markdown或textile等简单的标记语言写作，再转换成各种主流的文本格式。不过想把中文编码的markdown转换成的格式良好的PDF还需要一些额外的帮助。 安装(Windows为例)下载对应的操作系统版本并安装。确定安装成功： 1pandoc --version 为了输出PDF还需要安装LaTex。Pandoc推荐MiKTex。转换时会自动获取需要的LaTex依赖包。 Mac OS请在下载页面获得帮助，我没有试过。Macbook空间太宝贵了。。 转换现在已经可以像下面这样进行转换了(注意，Pandoc输入和输出都使用UTF-8编码): 1pandoc test.markdown -o test.pdf 不过对于中文并没有这么简单。默认的LaText引擎pdflatex并不支持中文，我们需要在命令行中指定引擎为xelatex：--latex-engine=xelatex。此外还需要各种字体等配置才能正常的看到PDF。好在tzengyuxio提供了Latex转换模板。我们也可以编辑此模板，改变字体和各种边距行距等。最终的命令如下： 1pandoc resume.markdown -o resume.pdf --latex-engine=xelatex --template=pm-template.latex 这是这篇博文的PDF效果：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sublime Text快捷键 for Mac]]></title>
      <url>%2F2015%2F03%2F24%2FSublime-Text-Shortcuts-Mac%2F</url>
      <content type="text"><![CDATA[Sublime Text快捷键一览表(Mac) Edit Keypress Command ⌘ + X Cut line ⌘ + ↩ Insert line after ⌘ + ⇧ + ↩ Insert line before ⌘ + ⌃ + ↑ Move line/selection up ⌘ + ⌃ + ↓ Move line/selection down ⌘ + D Select word - Repeat to select next occurrence ⌘ + L Select line - Repeat to select next lines ⌃ + ⌘ + G Select all occurrences of current selection ⌃ + ⇧ + ↑ Extra cursor on the line above ⌃ + ⇧ + ↓ Extra cursor on the line below ⌃ + M Jump to closing parentheses Repeat to jump to opening parentheses ⌃ + ⇧ + M Select all contents of the current parentheses ⌃ + A Move to beginning of line ⌃ + E Move to end of line ⌘ + K, ⌘ + K Delete from cursor to end of line ⌘ + K + ⌫ Delete from cursor to start of line ⌘ + ] Indent current line(s) ⌘ + [ Un-indent current line(s) ⌘ + ⇧ + D Duplicate line(s) ⌘ + J Join line below to the end of the current line ⌘ + / Comment/un-comment current line ⌘ + ⌥ + / Block comment current selection ⌘ + Y Redo, or repeat last keyboard shortcut command ⌘ + ⇧ + V Paste and indent correctly ⌃ + Space Select next auto-complete suggestion ⌃ + U Soft undo; jumps to your last change before undoing change when repeated ⌃ + ⇧ + Up Column selection up ⌃ + ⇧ + Down Column selection down ⌃ + ⇧ + W Wrap Selection in html tag Navigation/Goto Anywhere Keypress Command ⌘ + P or ⌘ + T Quick-open files by name ⌘ + R Goto symbol Goto word in current file ⌃ + G Goto line in current file General Keypress Command ⌘ + ⇧ + P Command Palette ⌃ + ⌘ + F Python Console ⌃ + ⇧ + ⌘ + F Toggle fullscreen mode ⌃ + ` Toggle distraction-free mode ⌘ + K, ⌘ + B Toggle side bar ⌃ + ⇧ + P Show scope in status bar Find/Replace Keypress Command ⌘ + F Find ⌘ + ⌥ + F Replace ⌘ + ⇧ + F Find in files Scrolling Keypress Command ⌃ + V Scroll down one page ⌃ + L Center current line vertically in page ⌘ + Down Scroll to end of file ⌘ + Up Scroll to start of file Tabs Keypress Command ⌘ + ⇧ + t Open last closed tab ⌘ + [NUM] Jump to tab in current group where num is 1-9 ⌘ + 0 Jump to 10th tab in current group ⌘ + ⇧ + [ Cycle left through tabs ⌘ + ⇧ + ] Cycle right through tabs ^ + Tab Cycle up through recent tabs ⇧ + ^ + Tab Cycle down through recent tabs Find in files Split window Keypress Command ⌘ + ⌥ + 2 Split view into two columns ⌘ + ⌥ + 1 Revert view to single column ⌘ + ⌥ + 5 Set view to grid (4 groups) ⌃ + [NUM] Jump to group where num is 1-4 ⌃ + ⇧ + [NUM] Move file to specified group where num is 1-4 Bookmarks Keypress Command ⌘ + F2 Toggle bookmark F2 Next bookmark ⇧ + F2 Previous bookmark ⇧ + ⌘ + F2 Clear bookmark Text manipulation Keypress Command ⌘ + K, ⌘ + U Transform to Uppercase ⌘ + K, ⌘ + L Transform to Lowercase ⌘ + ⌃ + up, ⌘ + ⌃ + down Clip text upwards / downwards]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[让Redcarpet在Jekyll Github Pages中处理表格]]></title>
      <url>%2F2015%2F03%2F24%2FRender-Table-Using-Redcarpet%2F</url>
      <content type="text"><![CDATA[在_config.yml指定markdown解析器为Redcarpet后，还需配置其extensions来正确处理表格，值的格式为字符串数组 1234# in _config.ymlmarkdown: redcarpetredcarpet: extensions: ["tables"] 这样就可以用以下格式来书写表格，:冒号的位置代表了对齐的方向： 12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 输出： Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 其他可选的extensions参考Redcarpet的README 1234# in _config.ymlmarkdown: redcarpetredcarpet: extensions: ["no_intra_emphasis", "fenced_code_blocks", "autolink", "tables", "with_toc_data"]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于Jekyll]]></title>
      <url>%2F2015%2F03%2F24%2FAbout-Jekyll%2F</url>
      <content type="text"><![CDATA[Jekyll并不是一个博客软件，它只是一个静态网页生成引擎。它不包括页面模板和设计元素，我们需要自己实现他们。然而使用Jekyll我们可以使用markdown或者Html编写页面，在本机预览并通过Git推送到GitHub Pages上托管，无需数据库 如果嫌麻烦，可以试试JekyllBootstrap，虽然貌似很久之前原作者就不再更新，不过看上去有人接手了后续本版本的开发(0.4.0 - next release [ETA 03/29/2015])。本博客则fork自barryclark/jekyll-now]]></content>
    </entry>

    
  
  
</search>
